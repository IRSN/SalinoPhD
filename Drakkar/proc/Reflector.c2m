PARAMETER Multicompo ReflSpecs :: ::: LINKED_LIST ReflSpecs ; ;
PROCEDURE CreaStepList GetMolarMass MetalMix CreaMix CreaDilut
  Geo15x15 AdaptIso LefebvreLeb Koebke CurrFluxIntf ;
LINKED_LIST Assmb AssmbAu Discr DiscrAu ListeIsot ListeAutop
  Library LibDilut CP CALC XS AUTO_LIB MACRO MACRO_FUEL_1 MACRO_FUEL_2
  StepList MolarMasses FeNat CrNat SnNat NiNat ZrNat TiNat SiNat
  BNat AgNat CdNat SNat HfNat GdNat Zirc4 Incon SS304 M5 KNat
  InNat AIC HfR Gd2O3 BP ConcMode MacrRefl Edition nbZones FractionVol
  GEOM TRACK SYSTEM FLUX OUT ;
MODULE LIB: GEO: ASM: FLU: EDI: COMPO: DELETE: USS: UTL: END: ABORT:
  MAC: SNT: GREP: MSTR: ;

*---- General informations    --------------------------
*---
* File containing multigroup nuclear data
*---
STRING Evaluation := "JEFF311"  ;
STRING FileNuclData := "D172" Evaluation + ;
STRING  LibGenre ;
INTEGER LibId ;
STRING  AssType  := "UOX"  ; ! 3 Char: UOX, MOX, ou UGd
STRING  Gestion  := "TIH" ; ! TIH ou BEAV
STRING  ConfigPyrex := "None" ; ! None, Py8 ou Py12
INTEGER Teneur_I := 310    ; ! X.YY % -> XYY [ex. 3.70 % -> 370]
* Core boundary is mainly occupied by UOX assemblies, with
* a 3.10% enrichement. Therefore, this is the one used in
* the reflector calculation.
STRING TypeDil := "TOT" ;
REAL TempMod := 559.2 ; ! K
REAL PowMWT ;
INTEGER ThermaExpans := 0 ;

*--- Depletion Conditions
REAL    dmod tmod cbor tfuel barr ;
INTEGER BarType ;

*-------------------------------------------------------
* Procedures: - Create every burnup & parameters lists (CreaStepList)
*             - Retrieve molar masses (GetMolarMasses)
*             - Create Metal Mixes (MetalMix)
*             - Using all of the above, create a Library with LIB: (CreaMix)
*             - Generate tracking objects (Geo15x15)
*---- 1) Burnup & parameter lists ----------------------
StepList := CreaStepList ::
  <<Gestion>> <<AssType>> <<ConfigPyrex>> 'DUMMY' ;
GREP: StepList :: GETVAL 'DeplParam' 1 5
  >>dmod<< >>cbor<< >>barr<< >>tfuel<< >>tmod<< ;

*---- 2) Molar Masses ----------------------------------
MolarMasses := GetMolarMass :: <<FileNuclData>> <<Evaluation>> ;

*---- 3) Metal Mixes -----------------------------------
FeNat CrNat SnNat NiNat ZrNat TiNat SiNat KNat BNat AgNat
CdNat SNat HfNat InNat
Zirc4 Incon SS304 M5 AIC HfR GdNat Gd2O3 BP := MetalMix
MolarMasses ::
<<Evaluation>> <<Gestion>> ;

*---- 4) Library with all mixes ------------------------
Library ConcMode := CreaMix
FeNat CrNat SnNat NiNat ZrNat TiNat SiNat KNat BNat AgNat CdNat SNat
HfNat InNat Zirc4 Incon SS304 M5 AIC HfR GdNat Gd2O3 BP MolarMasses ::
<<FileNuclData>> <<Evaluation>> <<Gestion>> <<AssType>>
<<Teneur_I>> <<ThermaExpans>> <<CTRA>>
<<dmod>> <<cbor>> <<tfuel>> <<tmod>> <<TypeDil>>
>>PowMWT<< ;
ECHO "#PowMWT" PowMWT ;

*---- 5) Geometry & Tracking ---------------------------
EVALUATE BarType := barr R_TO_I ;
Assmb AssmbAu Discr DiscrAu := Geo15x15 ::
  <<Gestion>> <<AssType>> <<ConfigPyrex>> <<ThermaExpans>>
  <<BarType>> <<tfuel>> <<tmod>> ;
Assmb AssmbAu := DELETE: Assmb AssmbAu ;

*--------------------------------------------------------------------
* Loop over the 2 cases, in order to have two different spectrum ratios
*--------------------------------------------------------------------
ListeIsot ListeAutop := AdaptIso :: <<FileNuclData>> <<Evaluation>>
                         >>LibId<< >>LibGenre<< ;
STRING NomH2O NomH1 NomO16 NomB10 NomB11 NomFe54 ;
GREP: ListeIsot :: GETVAL 'H2O  ' <<LibId>> NVAL 8 >>NomH2O<<   ;
GREP: ListeIsot :: GETVAL 'H1   ' <<LibId>> NVAL 8 >>NomH1<<    ;
GREP: ListeIsot :: GETVAL 'O16  ' <<LibId>> NVAL 8 >>NomO16<<   ;
GREP: ListeIsot :: GETVAL 'B10  ' <<LibId>> NVAL 8 >>NomB10<<   ;
GREP: ListeIsot :: GETVAL 'B11  ' <<LibId>> NVAL 8 >>NomB11<<   ;
GREP: ListeIsot :: GETVAL 'Fe54 ' <<LibId>> NVAL 8 >>NomFe54<<  ;

REAL H1 O16 H2O B10 B11 ;
INTEGER CASE := 1 ;
WHILE CASE 2 <= DO

  IF CASE 1 = THEN ! Cas A
  !  EVALUATE CB := 500.0 ;  ! ppm
  !  EVALUATE Density := 0.55 ! g/cm3
    EVALUATE B10 := 3.04836E-06 ;
    EVALUATE B11 := 1.22700E-05 ;
    EVALUATE H1  := 3.67705E-02 ;
    EVALUATE O16 := 1.83852E-02 ;
    EVALUATE H2O := 0.          ;
  ELSEIF CASE 2 = THEN ! Cas B
  !  EVALUATE CB := 0.0 ; ! ppm
  !  EVALUATE Density := 0.7 ! g/cm3
    EVALUATE B10 := 0.00000E+00 ;
    EVALUATE B11 := 0.00000E+00 ;
    EVALUATE H1  := 4.67988E-02 ;
    EVALUATE O16 := 2.33994E-02 ;
    EVALUATE H2O := 0.          ;
  ENDIF ;

Library := LIB: Library ::
* Borated water
  MIXS LIB: <<LibGenre>> FIL: <<FileNuclData>>

  MIX 10 <<TempMod>>
    H1_H2O    = <<NomH1>>  <<H1>>  NOEV
    O16       = <<NomO16>> <<O16>> NOEV
    B10       = <<NomB10>> <<B10>> NOEV
    B11       = <<NomB11>> <<B11>> NOEV
  MIX 11 <<TempMod>>
    H1_H2O    = <<NomH1>>  <<H1>>  NOEV
    O16       = <<NomO16>> <<O16>> NOEV
    B10       = <<NomB10>> <<B10>> NOEV
    B11       = <<NomB11>> <<B11>> NOEV
  MIX 12 <<TempMod>>
    H1_H2O    = <<NomH1>>  <<H1>>  NOEV
    O16       = <<NomO16>> <<O16>> NOEV
    B10       = <<NomB10>> <<B10>> NOEV
    B11       = <<NomB11>> <<B11>> NOEV
  MIX 13 <<TempMod>>
    H1_H2O    = <<NomH1>>  <<H1>>  NOEV
    O16       = <<NomO16>> <<O16>> NOEV
    B10       = <<NomB10>> <<B10>> NOEV
    B11       = <<NomB11>> <<B11>> NOEV
  MIX 14 <<TempMod>>
    H1_H2O    = <<NomH1>>  <<H1>>  NOEV
    O16       = <<NomO16>> <<O16>> NOEV
    B10       = <<NomB10>> <<B10>> NOEV
    B11       = <<NomB11>> <<B11>> NOEV
;

  AUTO_LIB := USS: Library DiscrAu ::
    EDIT 0 GRMIN 45 MAXST 200 ;
  CP := ASM: AUTO_LIB Discr :: EDIT 0 ARM ;
  CALC := FLU: CP AUTO_LIB Discr ::
    TYPE B B1 SIGS ;
  XS := EDI: AUTO_LIB Discr CALC ::
    EDIT 0 SAVE MERGE COMP ;
* Recovery of fuel cross sections in Mix 1
  IF CASE 1 = THEN
    MACRO_FUEL_1 := XS :: STEP UP 'REF-CASE0001' STEP UP MACROLIB ;
  ELSEIF CASE 2 = THEN
    MACRO_FUEL_2 := XS :: STEP UP 'REF-CASE0001' STEP UP MACROLIB ;
  ENDIF ;
  AUTO_LIB CP CALC XS := DELETE: AUTO_LIB CP CALC XS ;
EVALUATE CASE := CASE 1 + ;
ENDWHILE ; ! Boucle sur les CASE

Library Discr := DELETE: Library Discr ;

! Pour avoir un NMIX assez grand pour le reflecteur, je ne parviens
! pas à me passer des MIX 3, 4 et 5 de Library ...
Library := LIB: ::
  NMIX 32
  MIXS LIB: <<LibGenre>> FIL: <<FileNuclData>>
  MIX 3 560.0 Fe54 = <<NomFe54>> 0.0 ! Dummy mix
  MIX 4 560.0 Fe54 = <<NomFe54>> 0.0 ! Dummy mix
  MIX 5 560.0 Fe54 = <<NomFe54>> 0.0 ! Dummy mix
;

*--------------------------------------------------------------------
*-------------------Beginning of reflector computations--------------
*--------------------------------------------------------------------
Multicompo := COMPO: :: EDIT 1
  STEP UP 'Radial'
    COMM 'Radial reflector XS, from IRSN/LN.' ENDC
    PARA 'C-BORE'      VALU REAL
    PARA 'Method'      VALU CHAR
    PARA 'dCloisEnvel' VALU REAL
    PARA 'Palier'      VALU CHAR
    INIT
  STEP UP 'Bottom'
    COMM 'Bottom reflector XS, from IRSN/LN.' ENDC
    PARA 'C-BORE'      VALU REAL
    PARA 'Method'      VALU CHAR
    INIT
  STEP UP 'Top'
    COMM 'Top reflector XS, from IRSN/LN.' ENDC
    PARA 'C-BORE'      VALU REAL
    PARA 'Method'      VALU CHAR
    INIT
  ;

* Gap where the flux is retrieved at the interface
REAL FluxGap := 0.005 ; ! [cm]

* Refined Zone, i.e. with a finer discretization
REAL RefZn := 6.0 ; ! [cm]
REAL RefZnR ;
INTEGER MeshClsEnvel ;

* Variables used to retrieve fluxes and currents at the interface
REAL SectionTot1 SectionTot2 Scat1to1 Scat1toAll Scat2toAll
  Current1_A Current2_A BndaryFlx1_A BndaryFlx2_A
  Current1_B Current2_B BndaryFlx1_B BndaryFlx2_B ;

* Variables for Koebke method
REAL SigmaAbs1_A SigmaAbs2_A SigmaRal_A
     SigmaAbs1_B SigmaAbs2_B SigmaRal_B ;

* Equivalent reflector cross sections and diffusion coefficients
REAL D1 D2 SigmaAbs1 SigmaAbs2 SigmaRalent Total1 Total2 f1 f2 ;

* Reflector parametrization variables
STRING Palier Method ;
REAL CB ; ! ppm
INTEGER iLocation iCB iMethod iPalier idxPalier nPalier iCloisEnvel
        nCloisEnvel ;

* CreaDilut variables
REAL dMod TMil fvMod fvZr4 fvInc fvSS304 fvHe ;
INTEGER iZone premierMIX ;
STRING Location ;

FractionVol := MSTR: :: CD 'Radial' ;
FractionVol := MSTR: FractionVol :: CD 'Bottom' ;
FractionVol := MSTR: FractionVol :: CD 'Top' ;

*---
*  Radial reflector
*---

* Dimensions
REAL dClois dCloisEnvel dEnvel dEnvelEcran dEcran ;
REAL FinClois DebutEnvel FinEnvel DebutEcran FinEcran DebutCuve ;

INTEGER nbZones := 4 ;
nbZones := UTL: :: CREA 'Radial' 1 = <<nbZones>> ;

* Steel volume fraction in the water between the baffle and the barrel,
* due to the horizontal steel reinforcement plates that are vertically
* distributed. Approximately 5-6%.
REAL fvacier := 0.05 ;
REAL fveau := 1.0 fvacier - ;

*---
*  Bottom reflector : dimensions, compositions and properties
*  From BEAVRS
*---
REAL BZone1 BZone2 BZone3 BZone4 ;
EVALUATE nbZones := 3 ;
EVALUATE BZone1 := 0.847 ; !1st layer (the closest to the core)
EVALUATE BZone2 := 15.16 ; !2nd layer
EVALUATE BZone3 := 20.00 ; !3rd layer (the farthest from the core)

nbZones := UTL: nbZones :: CREA 'Bottom' 1 = <<nbZones>> ;

FractionVol := UTL: FractionVol :: STEP UP 'Bottom'
  CREA 'Eau' <<nbZones>> = 0.618 0.625 1.000
  CREA 'Zr4' <<nbZones>> = 0.371 0.088 0.000
  CREA 'Inc' <<nbZones>> = 0.000 0.000 0.000
  CREA 'SS ' <<nbZones>> = 0.000 0.276 0.000
  CREA 'He ' <<nbZones>> = 0.000 0.000 0.000   ;

REAL dModBas := 0.753 ; ! Densité du modérateur en entrée du coeur
REAL TMilBas := 286.4 ; ! Temp du réflecteur bas (soit Tmod,entrée)
EVALUATE TMilBas := TMilBas 273.15 + ; ! Conversion en Kelvin

* DRAGON uses the abscissae, so the thicknesses must be cumulated.
EVALUATE BZone2 := BZone2 BZone1 + ;
EVALUATE BZone3 := BZone3 BZone2 + ;
EVALUATE BZone4 := BZone4 BZone3 + ;

*---
*  Top reflector : dimensions, compositions and properties
*  From BEAVRS
*---

* Dimensions du réflecteur haut (largeur de chaque tranche)
REAL HZone1 HZone2 HZone3 HZone4 HZone5 HZone6 HZone7 ;

EVALUATE HZone1 := 10.76 ; !1st layer (the closest to the core)
EVALUATE HZone2 :=  4.19 ; !2nd layer
EVALUATE HZone3 :=  4.50 ; !3rd layer
EVALUATE HZone4 :=  2.05 ; !4th layer
EVALUATE HZone5 :=  3.35 ; !5th layer
EVALUATE HZone6 :=  8.83 ; !6th layer
EVALUATE HZone7 := 20.00 ; !7th layer (the farthest from the core)

EVALUATE nbZones := 7 ;
nbZones := UTL: nbZones :: CREA 'Top' 1 = <<nbZones>> ;

! Fraction volumique pour la zone1, zone2, zone3, etc.
FractionVol := UTL: FractionVol :: STEP UP 'Top'
  CREA 'Eau' <<nbZones>> = 0.617 0.587 0.617 0.617 0.992 0.625 1.000
  CREA 'Zr4' <<nbZones>> = 0.096 0.096 0.096 0.372 0.008 0.088 0.000
  CREA 'Inc' <<nbZones>> = 0.007 0.032 0.007 0.000 0.000 0.000 0.000
  CREA 'SS ' <<nbZones>> = 0.000 0.005 0.000 0.000 0.000 0.276 0.000
  CREA 'He ' <<nbZones>> = 0.280 0.280 0.280 0.011 0.000 0.011 0.000 ;

REAL dModHaut  := 0.677 ; ! Densité du modérateur en entrée du coeur
REAL TMilHaut  := 320.1 ; ! Temp du réflecteur bas (soit Tmod,entrée)
EVALUATE TMilHaut := TMilHaut 273.15 + ; ! Conversion en Kelvin

* DRAGON uses the abscissae, so the thicknesses must be cumulated.
EVALUATE HZone2 := HZone2 HZone1 + ;
EVALUATE HZone3 := HZone3 HZone2 + ;
EVALUATE HZone4 := HZone4 HZone3 + ;
EVALUATE HZone5 := HZone5 HZone4 + ;
EVALUATE HZone6 := HZone6 HZone5 + ;
EVALUATE HZone7 := HZone7 HZone6 + ;

* Any additionnal parameterization loop can be added here. Example(s):
* - reflector moderator density,
* - ...

*--------------------------------------------------------------------
* Loop over boron concentration in reflector water
*--------------------------------------------------------------------
EVALUATE iCB := 1 ;
WHILE iCB 5 <= DO
  IF iCB 1 = THEN
    EVALUATE CB := 0.0 ; ! ppm
  ELSEIF iCB 2 = THEN
    EVALUATE CB := 200.0 ; ! ppm
  ELSEIF iCB 3 = THEN
    EVALUATE CB := 500.0 ; ! ppm
  ELSEIF iCB 4 = THEN
    EVALUATE CB := 1000.0 ; ! ppm
  ELSEIF iCB 5 = THEN
    EVALUATE CB := 2000.0 ; ! ppm
  ELSE
    ECHO "ERROR, iCB NOT RECOGNIZED" ;
    ABORT: ;
  ENDIF ;

  *--------------------------------------------------------------------
  * Loop over reflector locations
  *--------------------------------------------------------------------
  EVALUATE iLocation := 1 ;
  WHILE iLocation 3 <= DO
    IF iLocation 1 = THEN
      EVALUATE Location := 'Radial' ;
    ELSEIF iLocation 2 = THEN
      EVALUATE Location := 'Bottom' ;
    ELSEIF iLocation 3 = THEN
      EVALUATE Location := 'Top' ;
    ELSE
      ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
      ABORT: ;
    ENDIF ;

    IF Location 'Radial' = NOT THEN
      * For non-radial (i.e. top and bottom) reflectors, there is no
      * 'Palier' parameterization. It is therefore not necessary to
      * perform these calculations for each 'Palier'.
      EVALUATE nCloisEnvel := 1 ;
      EVALUATE nPalier := 1 ;
    ELSE
      GREP: ReflSpecs :: LENGTH 'dCloisEnvel' >>nCloisEnvel<< ;
      GREP: ReflSpecs :: LENGTH 'Paliers' >>nPalier<< ;
      * Each Palier is stored in two variables, so we must divide by
      * two in order to have the number of Paliers.
      EVALUATE nPalier := nPalier 2 / ;
    ENDIF ;

    * Distance between baffle and barrel (can be a function of
    * distance and therefore of the angle)
    EVALUATE iCloisEnvel := 1 ;
    WHILE iCloisEnvel nCloisEnvel <= DO
      GREP: ReflSpecs :: GETVAL 'dCloisEnvel' <<iCloisEnvel>> NVAL 1
        >>dCloisEnvel<< ;

      * Palier-dependant data
      EVALUATE iPalier := 1 ;
      WHILE iPalier nPalier <= DO
        EVALUATE idxPalier := iPalier 1 - 8 * 1 + ; ! 8 char per Palier
        GREP: ReflSpecs :: GETVAL 'Paliers' <<idxPalier>> NVAL 8
          >>Palier<< ;
        ECHO "Palier =" Palier ;

*----------------------------------------------------------------------
*       The geometry could be simplified beyond the baffle without
*       consequences. Can be verified in full core transport (CASMO in
*       MXN mode).
*----------------------------------------------------------------------
        IF Palier 'CP0_900' = THEN
* --------------------------------
*         Geometry in cm, at cold temperatures (without thermal
*         expansion), from "In-core fuel management code package
*         validation for PWRs", IAEA-TECDOC-815, 1995.
*         http://www.iaea.org/inis/
*         collection/NCLCollectionStore/_Public/26/077/26077395.pdf
* --------------------------------
          EVALUATE dClois dEnvel dEnvelEcran dEcran :=
                   2.8575 5.1    6.0         6.8     ;
          EVALUATE RefZnR := 3.5 ;
        ELSEIF Palier 'BEAVRS' = THEN
          EVALUATE dClois   dEnvel dEnvelEcran dEcran :=
                   2.2225 5.715    0.5         5.715    ;
          EVALUATE RefZnR := 3.5 ;
        ELSEIF Palier 'CASMO5_MxN_2' = THEN
          EVALUATE dClois   dEnvel dEnvelEcran dEcran :=
                   2.529882 5.1    6.0         6.8    ;
          EVALUATE RefZnR := 3.5 ;
        ELSEIF Palier 'CASMO5_MxN_3' = THEN
          EVALUATE dClois   dEnvel dEnvelEcran dEcran :=
                   3.794823 5.1    6.0         6.8    ;
          EVALUATE RefZnR := 5.0 ;
        ELSE
          ECHO "Palier non-reconnu" ;
          ABORT: ;
        ENDIF ;

        * DRAGON uses the abscissae, so the thicknesses must be
        * cumulated.
        EVALUATE FinClois := dClois ;
        EVALUATE DebutEnvel := FinClois dCloisEnvel + ;
        EVALUATE FinEnvel := DebutEnvel dEnvel + ;
        EVALUATE DebutEcran := FinEnvel dEnvelEcran + ;
        EVALUATE FinEcran := DebutEcran dEcran + ;
        EVALUATE DebutCuve := FinEcran 20.0 + ;

        EVALUATE nbZones := 4 ;
        ! Volume fraction for zone1, zone2, zone3, etc.
        FractionVol := UTL: FractionVol :: STEP UP 'Radial'
                            ! MIX  6  7           8  9
          CREA 'Eau' <<nbZones>> = 0. <<fveau>>   1. 0.
          CREA 'Zr4' <<nbZones>> = 0. 0.          0. 0.
          CREA 'Inc' <<nbZones>> = 0. 0.          0. 0.
          CREA 'SS ' <<nbZones>> = 1. <<fvacier>> 0. 1.
          CREA 'He ' <<nbZones>> = 0. 0.          0. 0. ;
        *------------------------------------------------------------
        *  Loop on the two cases, to have two different spectrum
        *  ratios
        *------------------------------------------------------------
        EVALUATE CASE := 1 ;
        WHILE CASE 2 <= DO

          IF CASE 1 = THEN
            MACRO := MACRO_FUEL_1 ;
          ELSEIF CASE 2 = THEN
            MACRO := MACRO_FUEL_2 ;
          ENDIF ;

          MACRO := MAC: MACRO Library ::
            NMIX 15
            MIX 3 3 OLDL ! Dummy mix
            MIX 4 4 OLDL ! Dummy mix
            MIX 5 5 OLDL ! Dummy mix
          ;
          ! MACRO := UTL: MACRO :: DUMP ;

          *----------------------------------------------------------
          *  Reflector geometry
          *----------------------------------------------------------

          IF Location "Bottom" = Location "Radial" = + THEN
            EVALUATE dMod := dModBas ;
            EVALUATE TMil := TMilBas ;
          ELSEIF Location "Top" = THEN
            EVALUATE dMod := dModBas ;
            EVALUATE TMil := TMilBas ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;

          GREP: nbZones :: GETVAL <<Location>> 1 >>nbZones<< ;
          EVALUATE iZone := 1 ;
          WHILE iZone nbZones <= DO
            * Recovery of zone composition
            GREP: FractionVol :: STEP UP <<Location>>
                                 GETVAL 'Eau' <<iZone>> >>fvMod<<
                                 GETVAL 'Zr4' <<iZone>> >>fvZr4<<
                                 GETVAL 'Inc' <<iZone>> >>fvInc<<
                                 GETVAL 'SS ' <<iZone>> >>fvSS304<<
                                 GETVAL 'He ' <<iZone>> >>fvHe<<    ;
            * Display zone composition
            ECHO "[Refl" Location
                 "] Zone composition : " iZone ;
            ECHO "- eau   : " fvMod ' ;' ;
            ECHO "- Zr4   : " fvZr4 ' ;' ;
            ECHO "- Inc   : " fvInc ' ;' ;
            ECHO "- SS304 : " fvSS304 ' ;' ;
            ECHO "- He    : " fvHe '.' ;
            * Definition of reflector libraries
            LibDilut ConcMode MolarMasses
            BNat Zirc4 Incon SS304 := CreaDilut ::
            <<dMod>> <<TMil>> <<CB>> <<fvMod>> <<fvZr4>> <<fvInc>>
            <<fvSS304>> <<FileNuclData>> <<Evaluation>> ;
            * The MIX numbers are defined starting from 6
            EVALUATE premierMIX := 5 iZone + ;
            ECHO 'Premier MIX : ' premierMIX ;
            * Recovery of zone's constitutive media
            MACRO := MAC: MACRO LibDilut ::
              MIX <<premierMIX>> 1 OLDL ;
            * If this is the first layer, we define the MIX in which
            * the flux will be retrieved
            IF iZone 1 = THEN
              MACRO := MAC: MACRO LibDilut ::
                MIX 2 1 OLDL ; ! Retrieve flux in this MIX
            ENDIF ;
            LibDilut := DELETE: LibDilut ;
            EVALUATE iZone := iZone 1 + ;
          ENDWHILE ;
          IF Location "Radial" = THEN
            ! Mondot's advices based on generalized beta experience :
            ! * 4000 meshes
            ! * S16 (SN with N=16)
            EVALUATE MeshClsEnvel := dCloisEnvel 0.4 / R_TO_I ;
            ECHO "MeshClsEnvel (troncature)=" MeshClsEnvel ;

            GEOM := GEO: :: CAR1D 9
              X- ALBE 1.0 X+ VOID
              MESHX    -21.5 0.0 <<FluxGap>> <<FinClois>> <<RefZnR>>
              <<DebutEnvel>> <<FinEnvel>> <<DebutEcran>> <<FinEcran>>
              <<DebutCuve>>
              MIX           1   2           6            7          7
                      ! comb flux-acier   acier     eau+ac     eau+ac
                            6            8              9           8
                      ! acier         eau        acier(si ecran)  eau
              SPLITX       30   1           25    20 <<MeshClsEnvel>>
                           10           5              6            4
              ;
          ELSEIF Location "Bottom" = THEN
            GEOM := GEO: :: CAR1D 6
             X- ALBE 1.0 X+ VOID
             MESHX  -21.5 0.0 <<FluxGap>> <<BZone1>> <<RefZn>>
                    <<BZone2>> <<BZone3>>
             MIX         1   2           6          7          7
                             8
             SPLITX      40  1           60         60         50
                             50
             ;
          ELSEIF Location "Top" = THEN
            GEOM := GEO: :: CAR1D 10
              X- ALBE 1.0 X+ VOID
              MESHX  -21.5 0.0 <<FluxGap>> <<RefZn>> <<HZone1>>
                      <<HZone2>> <<HZone3>> <<HZone4>> <<HZone5>>
                      <<HZone6>> <<HZone7>>
              MIX         1   2          6          6          7
                                8          9          10         11
                          12
              SPLITX     40   1          60         50         50
                                50         50         50         50
                          50
              ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;

          *----------------------------------------------------------
          *  Solve flux
          *----------------------------------------------------------
          TRACK := SNT: GEOM ::
            EDIT 1
            MAXR 100000
            SN 16 SCAT 2 QUAD 10 ;
          SYSTEM := ASM: MACRO TRACK :: ARM ;
          FLUX := FLU: SYSTEM MACRO TRACK :: EDIT 0 TYPE K ;

          *----------------------------------------------------------
          *  Uncomment to plot 2-groups 1D fluxes
          *----------------------------------------------------------
          ! OUT := EDI: MACRO TRACK FLUX GEOM ::
          !   EDIT 3 UPS COND 0.625 SAVE ;
          ! OUT := UTL: OUT :: DUMP ;
          ! OUT := DELETE: OUT ;

          * The current at the interface can be obtained from the
          * reaction rates in the fuel. As for the flux at the
          * interface, two approaches are possible :
          * (1) We can evaluate the flux in a very fine mesh next to
          *     the interface
          * (2) We can take the average of two meshes on each side of
          *     the interface.
          * We chose the first option for simplicity's sake.

          IF Location "Radial" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 3 UPS MERGE MIX 1 2 0 0 0 0 0 0 0
              COND 0.625 SAVE ;
          ELSEIF Location "Bottom" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 3 UPS MERGE MIX 1 2 0 0 0 0 0 0
              COND 0.625 SAVE ;
          ELSEIF Location "Top" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 3 UPS MERGE MIX 1 2 0 0 0 0 0 0 0 0 0 0
              COND 0.625 SAVE ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;
          *---
          *  Compute currents and fluxes at the boundary
          *---
          IF CASE 1 = THEN
            CurrFluxIntf OUT :: >>BndaryFlx1_A<< >>BndaryFlx2_A<<
              >>Current1_A<< >>Current2_A<< ;
          ELSEIF CASE 2 = THEN
            CurrFluxIntf OUT :: >>BndaryFlx1_B<< >>BndaryFlx2_B<<
              >>Current1_B<< >>Current2_B<< ;
          ENDIF ;
          OUT := DELETE: OUT ;
          *---
          *  Additionnal output for Koebke method
          *---
          IF Location "Radial" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
            EDIT 5 UPS MERGE MIX 0 1 0 0 0 1 1 1 1
            COND 0.625 SAVE ;
          ELSEIF Location "Bottom" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 5 UPS MERGE MIX 0 1 0 0 0 1 1 1
              COND 0.625 SAVE ;
          ELSEIF Location "Top" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 5 UPS MERGE MIX 0 1 0 0 0 1 1 1 1 1 1 1
              COND 0.625 SAVE ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;

          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 1 GETVAL
            'NTOT0' 1 >>SectionTot1<< ;

          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 2 GETVAL
            'NTOT0' 1 >>SectionTot2<< ;

          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 1 GETVAL
            'SIGW00' 1 >>Scat1to1<< ;

          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 1 GETVAL
            'SIGS00' 1 >>Scat1toAll<< ;

          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 2 GETVAL
            'SIGS00' 1 >>Scat2toAll<< ;

          IF CASE 1 = THEN
            EVALUATE SigmaAbs1_A := SectionTot1 Scat1toAll - ;
            EVALUATE SigmaAbs2_A := SectionTot2 Scat2toAll - ;
            EVALUATE SigmaRal_A := Scat1toAll Scat1to1 - ;
          ELSEIF CASE 2 = THEN
            EVALUATE SigmaAbs1_B := SectionTot1 Scat1toAll - ;
            EVALUATE SigmaAbs2_B := SectionTot2 Scat2toAll - ;
            EVALUATE SigmaRal_B := Scat1toAll Scat1to1 - ;
          ENDIF ;

          GEOM TRACK SYSTEM FLUX MACRO OUT := DELETE:
          GEOM TRACK SYSTEM FLUX MACRO OUT ;

          EVALUATE CASE := CASE 1 + ;
        ENDWHILE ; ! Boucle sur les CASE

        IF BndaryFlx2_A BndaryFlx1_A /
           BndaryFlx2_B BndaryFlx1_B / / 1.0 - ABS 0.01 < THEN
          ECHO "The two calculations (for different 2 spectrum " ;
          ECHO "ratios) are much too close, as they have the same " ;
          ECHO "spectrum ratios. Check that the calculations are " ;
          ECHO "indeed different. If they are, find a way to " ;
          ECHO "separate them more." ;
          ABORT: ;
        ENDIF ;

        EVALUATE iMethod := 1 ;
        WHILE iMethod 7 <= DO
          IF     iMethod 1 = THEN EVALUATE Method := "Lefebvre-Leb" ;
          ELSEIF iMethod 2 = THEN EVALUATE Method := "Koebke-a" ;
          ELSEIF iMethod 3 = THEN EVALUATE Method := "Koebke-aDF" ;
          ELSEIF iMethod 4 = THEN EVALUATE Method := "Koebke-ab" ;
          ELSEIF iMethod 5 = THEN EVALUATE Method := "Koebke-abDF" ;
          ELSEIF iMethod 6 = THEN EVALUATE Method := "Koebke-b" ;
          ELSEIF iMethod 7 = THEN EVALUATE Method := "Koebke-bDF" ;
          ELSE
            ECHO "Reflector method not recognized." ;
            ABORT: ;
          ENDIF ;

          IF Method "Lefebvre-Leb" = THEN
            LefebvreLeb :: <<Current1_A>> <<BndaryFlx1_A>>
                           <<Current1_B>> <<BndaryFlx1_B>>
                           <<Current2_A>> <<BndaryFlx2_A>>
                           <<Current2_B>> <<BndaryFlx2_B>>
                           >>D1<< >>D2<< >>SigmaAbs1<< >>SigmaAbs2<<
                           >>SigmaRalent<< >>f1<< >>f2<< ;
          ELSEIF Method "Koebke-a" =
                 Method "Koebke-aDF" = +
                 Method "Koebke-ab" = +
                 Method "Koebke-abDF" = +
                 Method "Koebke-b" = +
                 Method "Koebke-bDF" = + THEN
            Koebke :: <<Current1_A>> <<BndaryFlx1_A>>
                      <<Current1_B>> <<BndaryFlx1_B>>
                      <<Current2_A>> <<BndaryFlx2_A>>
                      <<Current2_B>> <<BndaryFlx2_B>>
                      <<SigmaAbs1_A>> <<SigmaAbs2_A>>
                      <<SigmaAbs1_B>> <<SigmaAbs2_B>>
                      <<SigmaRal_A>>  <<SigmaRal_B>>
                      <<Method>> <<Location>>
                      >>D1<< >>D2<< >>SigmaAbs1<< >>SigmaAbs2<<
                      >>SigmaRalent<< >>f1<< >>f2<< ;
          ELSE
            ECHO Method " reflector method is unknown." ;
            ABORT: ;
          ENDIF ;
          *--------------------------------------------------------
          *  Creating a Macrolib with the XS reflectors calculated
          *  in the previous step
          *--------------------------------------------------------
          EVALUATE Total1 := SigmaAbs1 SigmaRalent + ;
          EVALUATE Total2 := SigmaAbs2 ;
          MacrRefl := MAC: ::
            EDIT 3 NGRO 2 NMIX 1 NIFI 0 ANIS 1 CTRA NONE NADF 1
            ENER 2.0E7 0.625 1.0E-3 VOLUME 1.0 READ INPUT MIX 1
              FLUX-INTG 1.0 1.0
              TOTAL <<Total1>> <<Total2>>
              DIFF  <<D1>> <<D2>>
              SCAT 2 2 (*2->1*) 0.0 (*1->1*) 0.0
                   2 2 (*2->2*) 0.0 (*1->2*) <<SigmaRalent>>
              ADF 'FD_B' <<f1>> <<f2>> ;
          Edition := EDI: MacrRefl :: EDIT 1 ADFM SAVE ;
          IF Location 'Radial' = THEN
            Multicompo := COMPO: Multicompo Edition :: EDIT 1
              STEP UP <<Location>>
              C-BORE <<CB>>
              Method <<Method>>
              dCloisEnvel <<dCloisEnvel>>
              Palier <<Palier>>
              MACRO ;
          ELSE
            Multicompo := COMPO: Multicompo Edition :: EDIT 1
              STEP UP <<Location>>
              C-BORE <<CB>>
              Method <<Method>>
              MACRO ;
          ENDIF ;
          MacrRefl Edition := DELETE: MacrRefl Edition ;

          EVALUATE iMethod := iMethod 1 + ;
        ENDWHILE ; ! Loop over Method

        EVALUATE iPalier := iPalier 1 + ;
      ENDWHILE ; ! Loop over iPalier

      EVALUATE iCloisEnvel := iCloisEnvel 1 + ;
    ENDWHILE ; ! Loop over iCloisEnvel

    EVALUATE iLocation := iLocation 1 + ;
  ENDWHILE ; ! Loop over iLocation

  EVALUATE iCB := iCB 1 + ;
ENDWHILE ; ! Loop over iCB

END: ;
QUIT "LIST" .
