PARAMETER Multicompo ReflSpecs TENDL
  :: ::: LINKED_LIST ReflSpecs TENDL ; ;
PROCEDURE CreaStepList GetMolarMass MetalMix CreaMix CreaDilut
  Geo15x15 AdaptIso LefebvreLeb Koebke CurrFluxIntf GetTechData ;
LINKED_LIST Assmb AssmbAu Discr DiscrAu ListeIsot ListeAutop Library
  LibDilut CP CALC XS AUTO_LIB MACRO MACRO_FUEL_1 MACRO_FUEL_2 StepList
  MolarMasses FeNat CrNat SnNat NiNat ZrNat TiNat SiNat BNat AgNat CdNat
  SNat HfNat GdNat Zirc4 Incon SS304 M5 KNat InNat AIC HfR Gd2O3 BP
  ConcMode MacrRefl Edition nbZones FractionVol Boron GEOM TRACK SYSTEM
  FLUX OUT List ;
MODULE LIB: GEO: ASM: FLU: EDI: COMPO: DELETE: USS: UTL: END: ABORT:
  MAC: SNT: GREP: MSTR: INFO: ;

*---- General informations    --------------------------
*---
* File containing multigroup nuclear data
*---
STRING Evaluation := "JEFF311"  ;
STRING FileNuclData := "D172" Evaluation + ;
STRING  LibGenre ;
INTEGER LibId ;
STRING  AssType  := "UOX"  ; ! 3 Char: UOX, MOX, ou UGd
STRING  Gestion  := "TIH" ; ! TIH ou BEAV
STRING  ConfigPyrex := "None" ; ! None, Py8 ou Py12
INTEGER Teneur_I := 310    ; ! X.YY % -> XYY [ex. 3.70 % -> 370]
* Core boundary is mainly occupied by UOX assemblies, with
* a 3.10% enrichement. Therefore, this is the one used in
* the reflector calculation.
STRING CTRA := "APOL" ;
STRING TypeDil := "TOT" ;
REAL TempMod := 559.2 ; ! K
REAL PowMWT ;
INTEGER ThermaExpans := 0 ;

*--- Depletion Conditions
REAL    dmod tmod cbor tfuel barr ;
INTEGER BarType ;

*-------------------------------------------------------
* Procedures:
* - Create every burnup & parameters lists (CreaStepList)
* - Retrieve molar masses (GetMolarMasses)
* - Create Metal Mixes (MetalMix)
* - Using all of the above, create a Library with LIB: (CreaMix)
* - Generate tracking objects (Geo15x15)
*---- 1) Burnup & parameter lists ----------------------
StepList := CreaStepList ::
  <<Gestion>> <<AssType>> <<ConfigPyrex>> 'DUMMY' ;
GREP: StepList :: GETVAL 'DeplParam' 1 5
  >>dmod<< >>cbor<< >>barr<< >>tfuel<< >>tmod<< ;

*---- 2) Molar Masses ----------------------------------
MolarMasses := GetMolarMass :: <<FileNuclData>> <<Evaluation>> ;

*---- 3) Metal Mixes -----------------------------------
FeNat CrNat SnNat NiNat ZrNat TiNat SiNat KNat BNat AgNat
CdNat SNat HfNat InNat
Zirc4 Incon SS304 M5 AIC HfR GdNat Gd2O3 BP := MetalMix
MolarMasses ::
<<Evaluation>> <<Gestion>> ;

*---- 4) Library with all mixes ------------------------
Library ConcMode := CreaMix
FeNat CrNat SnNat NiNat ZrNat TiNat SiNat KNat BNat AgNat CdNat SNat
HfNat InNat Zirc4 Incon SS304 M5 AIC HfR GdNat Gd2O3 BP MolarMasses
TENDL ::
<<FileNuclData>> <<Evaluation>> <<Gestion>> <<AssType>>
<<Teneur_I>> <<ThermaExpans>> <<CTRA>>
<<dmod>> <<cbor>> <<tfuel>> <<tmod>> <<TypeDil>>
>>PowMWT<< ;
ECHO "#PowMWT" PowMWT ;

*---- 5) Geometry & Tracking ---------------------------
EVALUATE BarType := barr R_TO_I ;
Assmb AssmbAu Discr DiscrAu := Geo15x15 ::
  <<Gestion>> <<AssType>> <<ConfigPyrex>> <<ThermaExpans>>
  <<BarType>> <<tfuel>> <<tmod>> ;
Assmb AssmbAu := DELETE: Assmb AssmbAu ;

*--------------------------------------------------------------------
* Loop over the 2 cases, in order to have two different spectrum ratios
*--------------------------------------------------------------------
ListeIsot ListeAutop := AdaptIso :: <<FileNuclData>> <<Evaluation>>
                         >>LibId<< >>LibGenre<< ;
STRING NomH2O NomH1 NomO16 NomB10 NomB11 NomFe54 ;
GREP: ListeIsot :: GETVAL 'H2O  ' <<LibId>> NVAL 8 >>NomH2O<<   ;
GREP: ListeIsot :: GETVAL 'H1   ' <<LibId>> NVAL 8 >>NomH1<<    ;
GREP: ListeIsot :: GETVAL 'O16  ' <<LibId>> NVAL 8 >>NomO16<<   ;
GREP: ListeIsot :: GETVAL 'B10  ' <<LibId>> NVAL 8 >>NomB10<<   ;
GREP: ListeIsot :: GETVAL 'B11  ' <<LibId>> NVAL 8 >>NomB11<<   ;
GREP: ListeIsot :: GETVAL 'Fe54 ' <<LibId>> NVAL 8 >>NomFe54<<  ;

*--------------------------------------------------------------------
* TENDL specifics
*--------------------------------------------------------------------
INTEGER O16tendl ;
GREP: TENDL :: GETVAL 'O16'  1 >>O16tendl<< ;
STRING NomO16tendl ;
IF O16tendl 10 < THEN
  EVALUATE NomO16tendl := "O16_00" O16tendl I_TO_S + ;
ELSEIF O16tendl 100 < THEN
  EVALUATE NomO16tendl := "O16_0" O16tendl I_TO_S + ;
ELSE
  EVALUATE NomO16tendl := "O16_" O16tendl I_TO_S + ;
ENDIF ;

REAL H1 O16 H2O B10 B11 ;
INTEGER CASE := 1 ;
WHILE CASE 2 <= DO

  IF CASE 1 = THEN ! Cas A
  !  EVALUATE CB := 500.0 ;  ! ppm
  !  EVALUATE Density := 0.55 ! g/cm3
    EVALUATE B10 := 3.04836E-06 ;
    EVALUATE B11 := 1.22700E-05 ;
    EVALUATE H1  := 3.67705E-02 ;
    EVALUATE O16 := 1.83852E-02 ;
    EVALUATE H2O := 0.          ;
  ELSEIF CASE 2 = THEN ! Cas B
  !  EVALUATE CB := 0.0 ; ! ppm
  !  EVALUATE Density := 0.7 ! g/cm3
    EVALUATE B10 := 0.00000E+00 ;
    EVALUATE B11 := 0.00000E+00 ;
    EVALUATE H1  := 4.67988E-02 ;
    EVALUATE O16 := 2.33994E-02 ;
    EVALUATE H2O := 0.          ;
  ENDIF ;

  Library := LIB: Library ::
  ! Borated water
    MIXS LIB: <<LibGenre>> FIL: <<FileNuclData>>

    MIX 5 <<TempMod>>
      H1_H2O    = <<NomH1>>  <<H1>>  NOEV
      O16       = <<NomO16>> <<O16>> NOEV
      B10       = <<NomB10>> <<B10>> NOEV
      B11       = <<NomB11>> <<B11>> NOEV
    MIX 6 <<TempMod>>
      H1_H2O    = <<NomH1>>  <<H1>>  NOEV
      O16       = <<NomO16>> <<O16>> NOEV
      B10       = <<NomB10>> <<B10>> NOEV
      B11       = <<NomB11>> <<B11>> NOEV
    MIX 10 <<TempMod>>
      H1_H2O    = <<NomH1>>  <<H1>>  NOEV
      O16       = <<NomO16>> <<O16>> NOEV
      B10       = <<NomB10>> <<B10>> NOEV
      B11       = <<NomB11>> <<B11>> NOEV
    MIX 11 <<TempMod>>
      H1_H2O    = <<NomH1>>  <<H1>>  NOEV
      O16       = <<NomO16>> <<O16>> NOEV
      B10       = <<NomB10>> <<B10>> NOEV
      B11       = <<NomB11>> <<B11>> NOEV
    MIX 12 <<TempMod>>
      H1_H2O    = <<NomH1>>  <<H1>>  NOEV
      O16       = <<NomO16>> <<O16>> NOEV
      B10       = <<NomB10>> <<B10>> NOEV
      B11       = <<NomB11>> <<B11>> NOEV
    MIX 13 <<TempMod>>
      H1_H2O    = <<NomH1>>  <<H1>>  NOEV
      O16       = <<NomO16>> <<O16>> NOEV
      B10       = <<NomB10>> <<B10>> NOEV
      B11       = <<NomB11>> <<B11>> NOEV
  ;
  IF O16tendl -311 = NOT THEN
  Library := LIB: Library ::
  ! Borated water
    MIXS LIB: <<LibGenre>> FIL: draglibO16

    MIX 5 <<TempMod>>
      O16       = <<NomO16tendl>> <<O16>> NOEV
    MIX 6 <<TempMod>>
      O16       = <<NomO16tendl>> <<O16>> NOEV
    MIX 10 <<TempMod>>
      O16       = <<NomO16tendl>> <<O16>> NOEV
    MIX 11 <<TempMod>>
      O16       = <<NomO16tendl>> <<O16>> NOEV
    MIX 12 <<TempMod>>
      O16       = <<NomO16tendl>> <<O16>> NOEV
    MIX 13 <<TempMod>>
      O16       = <<NomO16tendl>> <<O16>> NOEV
  ;
  ENDIF ;
  AUTO_LIB := USS: Library DiscrAu ::
    EDIT 0 GRMIN 45 MAXST 200 ;
  CP := ASM: AUTO_LIB Discr :: EDIT 0 ARM ;
  CALC := FLU: CP AUTO_LIB Discr ::
    TYPE B B1 SIGS ;
  XS := EDI: AUTO_LIB Discr CALC ::
    EDIT 0 SAVE MERGE COMP ;
* Recovery of fuel cross sections in Mix 1
  IF CASE 1 = THEN
    MACRO_FUEL_1 := XS :: STEP UP 'REF-CASE0001' STEP UP MACROLIB ;
  ELSEIF CASE 2 = THEN
    MACRO_FUEL_2 := XS :: STEP UP 'REF-CASE0001' STEP UP MACROLIB ;
  ENDIF ;
  AUTO_LIB CP CALC XS := DELETE: AUTO_LIB CP CALC XS ;
EVALUATE CASE := CASE 1 + ;
ENDWHILE ; ! Boucle sur les CASE

Library Discr := DELETE: Library Discr ;

*--------------------------------------------------------------------
*-------------------Beginning of reflector computations--------------
*--------------------------------------------------------------------
Multicompo := COMPO: :: EDIT 1
  STEP UP 'Radial'
    COMM 'Radial reflector XS, from IRSN/LN.' ENDC
    PARA 'C-BORE'       VALU REAL
    PARA 'Method'       VALU CHAR
    PARA 'dBaffleBarrl' VALU REAL
    PARA 'Palier'       VALU CHAR
    INIT
  STEP UP 'Bottom'
    COMM 'Bottom reflector XS, from IRSN/LN.' ENDC
    PARA 'C-BORE'      VALU REAL
    PARA 'Method'      VALU CHAR
    INIT
  STEP UP 'Top'
    COMM 'Top reflector XS, from IRSN/LN.' ENDC
    PARA 'C-BORE'      VALU REAL
    PARA 'Method'      VALU CHAR
    INIT
  ;
* Gap where the flux is retrieved at the interface
REAL FluxGap := 0.005 ; ! [cm]
* Refined Zone, i.e. with a finer discretization
REAL RefZn := 6.0 ; ! [cm]
REAL RefZnR ;
INTEGER MeshClsBarrl ;
* Variables used to retrieve fluxes and currents at the interface
REAL SectionTot1 SectionTot2 Scat1to1 Scat1toAll Scat2toAll
  Current1_A Current2_A BndaryFlx1_A BndaryFlx2_A
  Current1_B Current2_B BndaryFlx1_B BndaryFlx2_B ;
* Variables for Koebke method
REAL SigmaAbs1_A SigmaAbs2_A SigmaSlowd_A
     SigmaAbs1_B SigmaAbs2_B SigmaSlowd_B ;
* Equivalent reflector cross sections and diffusion coefficients
REAL D1 D2 SigmaAbs1 SigmaAbs2 SigmaSlowd Total1 Total2 f1 f2 ;
* Reflector parametrization variables
STRING Palier Method ;
REAL CB ; ! ppm
INTEGER iCB nCB iLocation iBaffleBarrl nBaffleBarrl iPalier idxPalier
        nPalier iMethod ;
* Boron parametrization
Boron := UTL: :: CREA 'CB' 5 = 0.0 200.0 500.0 1000.0 2000.0 ; ! ppm
* CreaDilut variables
REAL OpePressure Temp dMod dModTop dModBottom
  fvMod fvZr4 fvInc fvSS304 fvHe ;
INTEGER iZone firstMIX ;
STRING Location ;
List := GetTechData :: 'TIH' 'UOX' 0 'None' 'GENERAL' ;
GREP: List :: GETVAL 'OpePressure' 1 >>OpePressure<< ;
List := DELETE: List ;
*
FractionVol := MSTR: :: CD 'Radial' ;
FractionVol := MSTR: FractionVol :: CD 'Bottom' ;
FractionVol := MSTR: FractionVol :: CD 'Top' ;
*---
*  Radial reflector
*---
* Dimensions
REAL dBaffle dBaffleBarrl dBarrl dBarrlShield dShield ;
REAL EndBaffle BegBarrl EndBarrl BegShield EndShield BegVessel ;
*
INTEGER nbZones := 4 ;
nbZones := UTL: :: CREA 'Radial' 1 = <<nbZones>> ;
* Steel volume fraction in the water between the baffle and the barrel,
* due to the horizontal steel reinforcement plates that are vertically
* distributed. Approximately 5-6%.
REAL fvsteel := 0.05 ;
REAL fvwater := 1.0 fvsteel - ;
*---
*  Bottom reflector : dimensions, compositions and properties
*  From BEAVRS
*---
REAL BZone1 := 0.847 ; !1st layer (the closest to the core)
REAL BZone2 := 15.16 ; !2nd layer
REAL BZone3 := 20.00 ; !3rd layer (the farthest from the core)
*
EVALUATE nbZones := 3 ;
nbZones := UTL: nbZones :: CREA 'Bottom' 1 = <<nbZones>> ;
*
! Volume fraction for zone1, zone2 and zone3.
FractionVol := UTL: FractionVol :: STEP UP 'Bottom'
  CREA 'Wat' <<nbZones>> = 0.618 0.625 1.000
  CREA 'Zr4' <<nbZones>> = 0.371 0.088 0.000
  CREA 'Inc' <<nbZones>> = 0.000 0.000 0.000
  CREA 'SS ' <<nbZones>> = 0.000 0.276 0.000
  CREA 'He ' <<nbZones>> = 0.000 0.000 0.000   ;
*
REAL TempBottom := 286.4 273.15 + ; ! Core inlet moderator temperature
INFO: :: TMP: <<TempBottom>> K PRES: <<OpePressure>> Pa PUR: 0.0 WGT%
  CALC DENS PWATER >>dModBottom<< ; ! [g.cm-3]
*
* DRAGON uses the abscissae, so the thicknesses must be cumulated.
EVALUATE BZone2 := BZone2 BZone1 + ;
EVALUATE BZone3 := BZone3 BZone2 + ;
*---
*  Top reflector : dimensions, compositions and properties
*  From BEAVRS
*---
REAL HZone1 := 10.76 ; !1st layer (the closest to the core)
REAL HZone2 :=  4.19 ; !2nd layer
REAL HZone3 :=  4.50 ; !3rd layer
REAL HZone4 :=  2.05 ; !4th layer
REAL HZone5 :=  3.35 ; !5th layer
REAL HZone6 :=  8.83 ; !6th layer
REAL HZone7 := 20.00 ; !7th layer (the farthest from the core)
*
EVALUATE nbZones := 7 ;
nbZones := UTL: nbZones :: CREA 'Top' 1 = <<nbZones>> ;
*
! Volume fraction for zone1, zone2, zone3, etc.
FractionVol := UTL: FractionVol :: STEP UP 'Top'
  CREA 'Wat' <<nbZones>> = 0.617 0.587 0.617 0.617 0.992 0.625 1.000
  CREA 'Zr4' <<nbZones>> = 0.096 0.096 0.096 0.372 0.008 0.088 0.000
  CREA 'Inc' <<nbZones>> = 0.007 0.032 0.007 0.000 0.000 0.000 0.000
  CREA 'SS ' <<nbZones>> = 0.000 0.005 0.000 0.000 0.000 0.276 0.000
  CREA 'He ' <<nbZones>> = 0.280 0.280 0.280 0.011 0.000 0.011 0.000 ;
*
REAL TempTop  := 320.1 273.15 + ; ! Core outlet moderator temperature
INFO: :: TMP: <<TempTop>> K PRES: <<OpePressure>> Pa PUR: 0.0 WGT%
  CALC DENS PWATER >>dModTop<< ; ! [g.cm-3]
*
* DRAGON uses the abscissae, so the thicknesses must be cumulated.
EVALUATE HZone2 := HZone2 HZone1 + ;
EVALUATE HZone3 := HZone3 HZone2 + ;
EVALUATE HZone4 := HZone4 HZone3 + ;
EVALUATE HZone5 := HZone5 HZone4 + ;
EVALUATE HZone6 := HZone6 HZone5 + ;
EVALUATE HZone7 := HZone7 HZone6 + ;
* Any additionnal parameterization loop can be added here. Example(s):
* - reflector moderator density,
* - ...
*--------------------------------------------------------------------
* Loop over boron concentration in reflector water
*--------------------------------------------------------------------
GREP: Boron :: LENGTH 'CB' >>nCB<< ;
EVALUATE iCB := 1 ;
WHILE iCB nCB <= DO
  GREP: Boron :: GETVAL 'CB' <<iCB>> NVAL 1 >>CB<< ;
  *--------------------------------------------------------------------
  * Loop over reflector locations
  *--------------------------------------------------------------------
  EVALUATE iLocation := 1 ;
  WHILE iLocation 3 <= DO
    IF iLocation 1 = THEN
      EVALUATE Location := 'Radial' ;
    ELSEIF iLocation 2 = THEN
      EVALUATE Location := 'Bottom' ;
    ELSEIF iLocation 3 = THEN
      EVALUATE Location := 'Top' ;
    ELSE
      ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
      ABORT: ;
    ENDIF ;
    IF Location 'Radial' = NOT THEN
      * For non-radial (i.e. top and bottom) reflectors, there is no
      * 'Palier' parameterization. It is therefore not necessary to
      * perform these calculations for each 'Palier'.
      EVALUATE nBaffleBarrl := 1 ;
      EVALUATE nPalier := 1 ;
    ELSE
      GREP: ReflSpecs :: LENGTH 'dBaffleBarrl' >>nBaffleBarrl<< ;
      GREP: ReflSpecs :: LENGTH 'Paliers' >>nPalier<< ;
      * Each Palier is stored in two variables, so we must divide by
      * two in order to have the number of Paliers.
      EVALUATE nPalier := nPalier 2 / ;
    ENDIF ;
    * Distance between baffle and barrel (can be a function of
    * distance and therefore of the angle)
    EVALUATE iBaffleBarrl := 1 ;
    WHILE iBaffleBarrl nBaffleBarrl <= DO
      GREP: ReflSpecs :: GETVAL 'dBaffleBarrl' <<iBaffleBarrl>> NVAL 1
        >>dBaffleBarrl<< ;
      * Palier-dependant data
      EVALUATE iPalier := 1 ;
      WHILE iPalier nPalier <= DO
        EVALUATE idxPalier := iPalier 1 - 8 * 1 + ; ! 8 char per Palier
        GREP: ReflSpecs :: GETVAL 'Paliers' <<idxPalier>> NVAL 8
          >>Palier<< ;
        ECHO "Palier =" Palier ;
*----------------------------------------------------------------------
*       The geometry could be simplified beyond the baffle without
*       consequences. Can be verified in full core transport (CASMO in
*       MXN mode).
*----------------------------------------------------------------------
        IF Palier 'CP0_900' = THEN
* --------------------------------
*         Geometry from inches to cm, at ambient temperature (without
*         thermal expansion) from "In-core fuel management code package
*         validation for PWRs", IAEA-TECDOC-815, 1995.
*         http://www.iaea.org/inis/
*         collection/NCLCollectionStore/_Public/26/077/26077395.pdf
* --------------------------------
          EVALUATE dBaffle := 9.0 8.0 / 2.54 * ; ! 9/8 in
          EVALUATE dBarrl  := 2.0       2.54 * ; ! 2 in
          EVALUATE dBarrlShield :=
            142.0 5.0 8.0 / + ! ID Barrel = 142+5/8 in
            133.0 7.0 8.0 / + ! ID Shield = 133+7/8 in
            2.0 2.0 * + !... to OD Shield = 137+7/8 in
            - 2.0 / 2.54 * ;
          EVALUATE dShield := 2.0 11.0 16.0 / + 2.54 * ; ! 2+11/16 in
          EVALUATE RefZnR := 3.5 ;
        ELSEIF Palier 'BEAVRS' = THEN
          EVALUATE dBaffle dBarrl dBarrlShield dShield :=
                   2.2225  5.715  0.5          5.715 ;
          EVALUATE RefZnR := 3.5 ;
        ELSEIF Palier 'CASMO5_MxN_2' = THEN
          EVALUATE dBaffle   dBarrl dBarrlShield dShield :=
                   2.529882  5.1    6.0          6.8 ;
          EVALUATE RefZnR := 3.5 ;
        ELSEIF Palier 'CASMO5_MxN_3' = THEN
          EVALUATE dBaffle   dBarrl dBarrlShield dShield :=
                   3.794823  5.1    6.0          6.8 ;
          EVALUATE RefZnR := 5.0 ;
        ELSE
          ECHO "Palier non-reconnu" ;
          ABORT: ;
        ENDIF ;
        * DRAGON uses the abscissae, so the thicknesses must be
        * cumulated.
        EVALUATE EndBaffle := dBaffle ;
        EVALUATE BegBarrl := EndBaffle dBaffleBarrl + ;
        EVALUATE EndBarrl := BegBarrl dBarrl + ;
        EVALUATE BegShield := EndBarrl dBarrlShield + ;
        EVALUATE EndShield := BegShield dShield + ;
        EVALUATE BegVessel := EndShield 20.0 + ;
        *
        EVALUATE nbZones := 4 ;
        ! Volume fraction for zone1, zone2, zone3, etc.
        FractionVol := UTL: FractionVol :: STEP UP 'Radial'
                            ! MIX  3  4           5  6
          CREA 'Wat' <<nbZones>> = 0. <<fvwater>> 1. 0.
          CREA 'Zr4' <<nbZones>> = 0. 0.          0. 0.
          CREA 'Inc' <<nbZones>> = 0. 0.          0. 0.
          CREA 'SS ' <<nbZones>> = 1. <<fvsteel>> 0. 1.
          CREA 'He ' <<nbZones>> = 0. 0.          0. 0. ;
        *------------------------------------------------------------
        *  Loop on the two cases, to have two different spectrum
        *  ratios
        *------------------------------------------------------------
        EVALUATE CASE := 1 ;
        WHILE CASE 2 <= DO
          IF CASE 1 = THEN
            MACRO := MACRO_FUEL_1 ;
          ELSEIF CASE 2 = THEN
            MACRO := MACRO_FUEL_2 ;
          ENDIF ;
          *----------------------------------------------------------
          *  Reflector geometry
          *----------------------------------------------------------
          IF Location "Bottom" = Location "Radial" = + THEN
            EVALUATE dMod := dModBottom ;
            EVALUATE Temp := TempBottom ;
          ELSEIF Location "Top" = THEN
            EVALUATE dMod := dModTop ;
            EVALUATE Temp := TempTop ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;
          GREP: nbZones :: GETVAL <<Location>> 1 >>nbZones<< ;
          EVALUATE iZone := 1 ;
          WHILE iZone nbZones <= DO
            * Recovery of zone composition
            GREP: FractionVol :: STEP UP <<Location>>
                                 GETVAL 'Wat' <<iZone>> >>fvMod<<
                                 GETVAL 'Zr4' <<iZone>> >>fvZr4<<
                                 GETVAL 'Inc' <<iZone>> >>fvInc<<
                                 GETVAL 'SS ' <<iZone>> >>fvSS304<<
                                 GETVAL 'He ' <<iZone>> >>fvHe<<    ;
            * Display zone composition
            ECHO "[Refl" Location
                 "] Zone composition : " iZone ;
            ECHO "- Water : " fvMod ' ;' ;
            ECHO "- Zr4   : " fvZr4 ' ;' ;
            ECHO "- Inc   : " fvInc ' ;' ;
            ECHO "- SS304 : " fvSS304 ' ;' ;
            ECHO "- He    : " fvHe '.' ;
            * Definition of reflector libraries
            LibDilut ConcMode MolarMasses
            BNat Zirc4 Incon SS304 := CreaDilut TENDL ::
            <<dMod>> <<Temp>> <<CB>> <<fvMod>> <<fvZr4>> <<fvInc>>
            <<fvSS304>> <<FileNuclData>> <<Evaluation>> ;
            * The MIX numbers are defined starting from 3
            EVALUATE firstMIX := 2 iZone + ;
            ECHO 'First MIX : ' firstMIX ;
            * Recovery of zone's constitutive media
            MACRO := MAC: MACRO LibDilut ::
              NMIX 9 MIX <<firstMIX>> 1 OLDL ;
            * If this is the first layer, we define the MIX in which
            * the flux will be retrieved
            IF iZone 1 = THEN
              MACRO := MAC: MACRO LibDilut ::
                MIX 2 1 OLDL ; ! Retrieve flux in this MIX
            ENDIF ;
            LibDilut := DELETE: LibDilut ;
            EVALUATE iZone := iZone 1 + ;
          ENDWHILE ;
          IF Location "Radial" = THEN
            ! Mondot's advices based on generalized beta experience :
            ! * 4000 meshes
            ! * S16 (SN with N=16)
            EVALUATE MeshClsBarrl := dBaffleBarrl 0.4 / R_TO_I ;
            ECHO "MeshClsBarrl (troncature)=" MeshClsBarrl ;
            *
            GEOM := GEO: :: CAR1D 9
              X- ALBE 1.0 X+ VOID
              MESHX    -21.5 0.0 <<FluxGap>> <<EndBaffle>> <<RefZnR>>
              <<BegBarrl>> <<EndBarrl>> <<BegShield>> <<EndShield>>
              <<BegVessel>>
              MIX           1   2           3             4          4
                      ! fuel flux+steel   steel water+steel water+steel
                          3            5             6             5
                      ! steel         water      steel(if screen) water
              SPLITX       30   1           25    20 <<MeshClsBarrl>>
                           10           5              6            4
              ;
          ELSEIF Location "Bottom" = THEN
            GEOM := GEO: :: CAR1D 6
             X- ALBE 1.0 X+ VOID
             MESHX  -21.5 0.0 <<FluxGap>> <<BZone1>> <<RefZn>>
                    <<BZone2>> <<BZone3>>
             MIX         1   2           3          4          4
                             5
             SPLITX      40  1           60         60         50
                             50
             ;
          ELSEIF Location "Top" = THEN
            GEOM := GEO: :: CAR1D 10
              X- ALBE 1.0 X+ VOID
              MESHX  -21.5 0.0 <<FluxGap>> <<RefZn>> <<HZone1>>
                      <<HZone2>> <<HZone3>> <<HZone4>> <<HZone5>>
                      <<HZone6>> <<HZone7>>
              MIX         1   2          3          3          4
                                5          6           7         8
                          9
              SPLITX     40   1          60         50         50
                                50         50         50         50
                          50
              ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;
          *----------------------------------------------------------
          *  Solve flux
          *----------------------------------------------------------
          TRACK := SNT: GEOM ::
            EDIT 1
            MAXR 100000
            SN 16 SCAT 2 QUAD 10 ;
          SYSTEM := ASM: MACRO TRACK :: ARM ;
          FLUX := FLU: SYSTEM MACRO TRACK :: EDIT 0 TYPE K ;
          *----------------------------------------------------------
          *  Uncomment to plot 2-groups 1D fluxes
          *----------------------------------------------------------
          ! OUT := EDI: MACRO TRACK FLUX GEOM ::
          !   EDIT 3 UPS COND 0.625 SAVE ;
          ! OUT := UTL: OUT :: DUMP ;
          ! OUT := DELETE: OUT ;
          * The current at the interface can be obtained from the
          * reaction rates in the fuel. As for the flux at the
          * interface, two approaches are possible :
          * (1) We can evaluate the flux in a very fine mesh next to
          *     the interface.
          * (2) We can take the average of two meshes on each side of
          *     the interface.
          * We chose the first option for simplicity's sake.
          IF Location "Radial" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 3 UPS MERGE MIX 1 2 0 0 0 0
              COND 0.625 SAVE ;
          ELSEIF Location "Bottom" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 3 UPS MERGE MIX 1 2 0 0 0
              COND 0.625 SAVE ;
          ELSEIF Location "Top" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 3 UPS MERGE MIX 1 2 0 0 0 0 0 0 0
              COND 0.625 SAVE ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;
          *---
          *  Compute currents and fluxes at the boundary
          *---
          IF CASE 1 = THEN
            CurrFluxIntf OUT :: >>BndaryFlx1_A<< >>BndaryFlx2_A<<
              >>Current1_A<< >>Current2_A<< ;
          ELSEIF CASE 2 = THEN
            CurrFluxIntf OUT :: >>BndaryFlx1_B<< >>BndaryFlx2_B<<
              >>Current1_B<< >>Current2_B<< ;
          ENDIF ;
          OUT := DELETE: OUT ;
          *---
          *  Additionnal output for Koebke method
          *---
          IF Location "Radial" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
            EDIT 5 UPS MERGE MIX 0 1 1 1 1 1
            COND 0.625 SAVE ;
          ELSEIF Location "Bottom" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 5 UPS MERGE MIX 0 1 1 1 1
              COND 0.625 SAVE ;
          ELSEIF Location "Top" = THEN
            OUT := EDI: MACRO TRACK FLUX GEOM ::
              EDIT 5 UPS MERGE MIX 0 1 1 1 1 1 1 1 1
              COND 0.625 SAVE ;
          ELSE
            ECHO "ERROR, REFLECTOR NOT RECOGNIZED" ;
            ABORT: ;
          ENDIF ;
          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 1
            GETVAL 'NTOT0'  1 >>SectionTot1<<
            GETVAL 'SIGW00' 1 >>Scat1to1<<
            GETVAL 'SIGS00' 1 >>Scat1toAll<< ;
          GREP: OUT :: STEP UP 'REF-CASE0001' STEP UP MACROLIB
            STEP UP 'GROUP' STEP AT (*GROUP*) 2
            GETVAL 'NTOT0'  1 >>SectionTot2<<
            GETVAL 'SIGS00' 1 >>Scat2toAll<< ;
          IF CASE 1 = THEN
            EVALUATE SigmaAbs1_A := SectionTot1 Scat1toAll - ;
            EVALUATE SigmaAbs2_A := SectionTot2 Scat2toAll - ;
            EVALUATE SigmaSlowd_A := Scat1toAll Scat1to1 - ;
          ELSEIF CASE 2 = THEN
            EVALUATE SigmaAbs1_B := SectionTot1 Scat1toAll - ;
            EVALUATE SigmaAbs2_B := SectionTot2 Scat2toAll - ;
            EVALUATE SigmaSlowd_B := Scat1toAll Scat1to1 - ;
          ENDIF ;
          GEOM TRACK SYSTEM FLUX MACRO OUT := DELETE:
          GEOM TRACK SYSTEM FLUX MACRO OUT ;
          EVALUATE CASE := CASE 1 + ;
        ENDWHILE ; ! Boucle sur les CASE
        IF BndaryFlx2_A BndaryFlx1_A /
           BndaryFlx2_B BndaryFlx1_B / / 1.0 - ABS 0.01 < THEN
          ECHO "The two calculations (for different 2 spectrum " ;
          ECHO "ratios) are much too close, as they have the same " ;
          ECHO "spectrum ratios. Check that the calculations are " ;
          ECHO "indeed different. If they are, find a way to " ;
          ECHO "separate them more." ;
          ABORT: ;
        ENDIF ;
        EVALUATE iMethod := 1 ;
        WHILE iMethod 7 <= DO
          IF     iMethod 1 = THEN EVALUATE Method := "Lefebvre-Leb" ;
          ELSEIF iMethod 2 = THEN EVALUATE Method := "Koebke-a" ;
          ELSEIF iMethod 3 = THEN EVALUATE Method := "Koebke-aDF" ;
          ELSEIF iMethod 4 = THEN EVALUATE Method := "Koebke-ab" ;
          ELSEIF iMethod 5 = THEN EVALUATE Method := "Koebke-abDF" ;
          ELSEIF iMethod 6 = THEN EVALUATE Method := "Koebke-b" ;
          ELSEIF iMethod 7 = THEN EVALUATE Method := "Koebke-bDF" ;
          ELSE
            ECHO "Reflector method not recognized." ;
            ABORT: ;
          ENDIF ;
          IF Method "Lefebvre-Leb" = THEN
            LefebvreLeb :: <<Current1_A>> <<BndaryFlx1_A>>
                           <<Current1_B>> <<BndaryFlx1_B>>
                           <<Current2_A>> <<BndaryFlx2_A>>
                           <<Current2_B>> <<BndaryFlx2_B>>
                           >>D1<< >>D2<< >>SigmaAbs1<< >>SigmaAbs2<<
                           >>SigmaSlowd<< >>f1<< >>f2<< ;
          ELSEIF Method "Koebke-a" =
                 Method "Koebke-aDF" = +
                 Method "Koebke-ab" = +
                 Method "Koebke-abDF" = +
                 Method "Koebke-b" = +
                 Method "Koebke-bDF" = + THEN
            Koebke :: <<Current1_A>> <<BndaryFlx1_A>>
                      <<Current1_B>> <<BndaryFlx1_B>>
                      <<Current2_A>> <<BndaryFlx2_A>>
                      <<Current2_B>> <<BndaryFlx2_B>>
                      <<SigmaAbs1_A>> <<SigmaAbs2_A>>
                      <<SigmaAbs1_B>> <<SigmaAbs2_B>>
                      <<SigmaSlowd_A>>  <<SigmaSlowd_B>>
                      <<Method>> <<Location>>
                      >>D1<< >>D2<< >>SigmaAbs1<< >>SigmaAbs2<<
                      >>SigmaSlowd<< >>f1<< >>f2<< ;
          ELSE
            ECHO Method " reflector method is unknown." ;
            ABORT: ;
          ENDIF ;
          *--------------------------------------------------------
          *  Creating a Macrolib with the XS reflectors calculated
          *  in the previous step
          *--------------------------------------------------------
          EVALUATE Total1 := SigmaAbs1 SigmaSlowd + ;
          EVALUATE Total2 := SigmaAbs2 ;
          MacrRefl := MAC: ::
            EDIT 3 NGRO 2 NMIX 1 NIFI 0 ANIS 1 CTRA NONE NADF 1
            ENER 2.0E7 0.625 1.0E-3 VOLUME 1.0 READ INPUT MIX 1
              FLUX-INTG 1.0 1.0
              TOTAL <<Total1>> <<Total2>>
              DIFF  <<D1>> <<D2>>
              SCAT 2 2 (*2->1*) 0.0 (*1->1*) 0.0
                   2 2 (*2->2*) 0.0 (*1->2*) <<SigmaSlowd>>
              ADF 'FD_B' <<f1>> <<f2>> ;
          Edition := EDI: MacrRefl :: EDIT 1 ADFM SAVE ;
          IF Location 'Radial' = THEN
            Multicompo := COMPO: Multicompo Edition :: EDIT 1
              STEP UP <<Location>>
              C-BORE <<CB>>
              Method <<Method>>
              dBaffleBarrl <<dBaffleBarrl>>
              Palier <<Palier>>
              MACRO ;
          ELSE
            Multicompo := COMPO: Multicompo Edition :: EDIT 1
              STEP UP <<Location>>
              C-BORE <<CB>>
              Method <<Method>>
              MACRO ;
          ENDIF ;
          MacrRefl Edition := DELETE: MacrRefl Edition ;
          *
          EVALUATE iMethod := iMethod 1 + ;
        ENDWHILE ; ! Loop over Method
        *
        EVALUATE iPalier := iPalier 1 + ;
      ENDWHILE ; ! Loop over iPalier
      *
      EVALUATE iBaffleBarrl := iBaffleBarrl 1 + ;
    ENDWHILE ; ! Loop over iBaffleBarrl
    *
    EVALUATE iLocation := iLocation 1 + ;
  ENDWHILE ; ! Loop over iLocation
  *
  EVALUATE iCB := iCB 1 + ;
ENDWHILE ; ! Loop over iCB
*
END: ;
QUIT "LIST" .
